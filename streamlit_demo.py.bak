from __future__ import annotations

import os
import requests
import streamlit as st
from typing import Any, Dict, Optional, List
from io import BytesIO

# =========================================================
# Configuration
# =========================================================
API_BASE_URL = os.getenv("JOB_ANALYZER_API_BASE_URL", "http://127.0.0.1:8011").rstrip("/")

st.set_page_config(
    page_title="Job Analyzer",
    layout="wide",
    initial_sidebar_state="collapsed",
)

# =========================================================
# Styling (web-like)
# =========================================================
st.markdown(
    """
    <style>
    .block-container { max-width: 1200px; padding-top: 1.2rem; }
    header[data-testid="stHeader"] { background: rgba(0,0,0,0); }
    div[data-testid="stToolbar"] { visibility: hidden; height: 0px; }

    .card {
        border: 1px solid rgba(49,51,63,0.18);
        border-radius: 16px;
        padding: 16px;
        background: rgba(255,255,255,0.85);
        margin-bottom: 16px;
    }

    .title {
        font-size: 28px;
        font-weight: 800;
        margin-bottom: 4px;
    }

    .subtitle {
        color: rgba(49,51,63,0.7);
        margin-bottom: 16px;
    }

    .pill {
        display: inline-block;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 12px;
        margin-right: 6px;
        border: 1px solid rgba(49,51,63,0.2);
    }

    .muted { color: rgba(49,51,63,0.65); }
    .small { font-size: 13px; }
    </style>
    """,
    unsafe_allow_html=True,
)

# =========================================================
# Helpers
# =========================================================
def api_get(path: str, token: Optional[str] = None):
    headers = {}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    r = requests.get(f"{API_BASE_URL}{path}", headers=headers)
    if r.status_code >= 400:
        raise RuntimeError(r.text)
    return r.json()

def api_post(path: str, payload: Dict[str, Any], token: Optional[str] = None):
    headers = {"Content-Type": "application/json"}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    r = requests.post(f"{API_BASE_URL}{path}", json=payload, headers=headers)
    if r.status_code >= 400:
        raise RuntimeError(r.text)
    return r.json()

def unwrap_profile_payload(resp: dict) -> dict:
    # resilient if backend returns {ok:true, profile:{...}} or directly profile dict
    if isinstance(resp, dict) and "profile" in resp and isinstance(resp["profile"], dict):
        return resp["profile"]
    return resp if isinstance(resp, dict) else {}

def extract_text_from_upload(uploaded_file) -> str:
    """
    Supports .txt, .pdf, .docx
    Extracts plain text locally, then we send to backend parser.
    """
    if uploaded_file is None:
        return ""

    name = (uploaded_file.name or "").lower()
    data = uploaded_file.read()

    if name.endswith(".txt"):
        return data.decode("utf-8", errors="ignore").strip()

    if name.endswith(".pdf"):
        try:
            from pypdf import PdfReader  # type: ignore
        except Exception:
            raise RuntimeError("PDF upload requires pypdf. Run: pip install pypdf")
        reader = PdfReader(BytesIO(data))
        pages: List[str] = []
        for p in reader.pages:
            pages.append(p.extract_text() or "")
        return "\n".join(pages).strip()

    if name.endswith(".docx"):
        try:
            import docx  # type: ignore
        except Exception:
            raise RuntimeError("DOCX upload requires python-docx. Run: pip install python-docx")
        doc = docx.Document(BytesIO(data))
        return "\n".join([p.text for p in doc.paragraphs]).strip()

    raise RuntimeError("Unsupported file type. Upload .txt, .pdf, or .docx.")

# =========================================================
# Session State
# =========================================================
st.session_state.setdefault("token", None)
st.session_state.setdefault("user", None)
st.session_state.setdefault("profile", {})
st.session_state.setdefault("mode", "Consumer")
st.session_state.setdefault("saved_matches", [])
st.session_state.setdefault("resume_paste", "")
st.session_state.setdefault("resume_parser_mode", "auto")

# =========================================================
# Header
# =========================================================
st.markdown(
    f"""
    <div class="card">
        <span class="pill">Consumer</span>
        <span class="pill">Enterprise</span>
        <span class="pill">API: {API_BASE_URL}</span>
        <div class="title">Job Analyzer</div>
        <div class="subtitle">
            Career intelligence for job seekers and hiring teams
        </div>
    </div>
    """,
    unsafe_allow_html=True,
)

# =========================================================
# Auth Gate
# =========================================================
if not st.session_state.token:
    st.markdown("## Account Access")

    tab_login, tab_register = st.tabs(["Login", "Register"])

    with tab_login:
        email = st.text_input("Email", key="login_email")
        password = st.text_input("Password", type="password", key="login_pw")
        if st.button("Login"):
            try:
                out = api_post("/auth/login", {"email": email, "password": password})
                st.session_state.token = out["token"]
                st.success("Logged in")
                st.rerun()
            except Exception as e:
                st.error(str(e))

    with tab_register:
        email = st.text_input("Email", key="reg_email")
        password = st.text_input("Password (8+ chars)", type="password", key="reg_pw")
        if st.button("Create account"):
            try:
                api_post("/auth/register", {"email": email, "password": password})
                st.success("Account created. You can now log in.")
            except Exception as e:
                st.error(str(e))

    st.stop()

# =========================================================
# Load profile
# =========================================================
try:
    st.session_state.profile = unwrap_profile_payload(api_get("/profile", st.session_state.token))
except Exception:
    st.session_state.profile = {}

# =========================================================
# Top Mode Buttons
# =========================================================
c1, c2, c3 = st.columns([1, 1, 3])

with c1:
    if st.button("Consumer", type="primary" if st.session_state.mode == "Consumer" else "secondary"):
        st.session_state.mode = "Consumer"

with c2:
    if st.button("Enterprise", type="primary" if st.session_state.mode == "Enterprise" else "secondary"):
        st.session_state.mode = "Enterprise"

with c3:
    if st.button("Logout"):
        api_post("/auth/logout", {}, st.session_state.token)
        st.session_state.token = None
        st.rerun()

# =========================================================
# Layout
# =========================================================
left, right = st.columns([1, 2])

# =========================================================
# Profile Snapshot + Resume Builder (always visible)
# =========================================================
with left:
    st.markdown("### Profile")
    p = st.session_state.profile or {}

    st.markdown(
        f"""
        <div class="card small">
            <b>Name:</b> {p.get("name","—")}<br/>
            <b>Location:</b> {p.get("location","—")}<br/>
            <b>Salary target:</b> {p.get("salary_min","—")}<br/>
            <b>Skills:</b><br/>
            <span class="muted">{(p.get("skills") or "")[:220]}</span>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.markdown("#### Build profile from resume")

    st.session_state.resume_parser_mode = st.selectbox(
        "Parsing mode",
        ["auto", "openai", "heuristic"],
        index=["auto","openai","heuristic"].index(st.session_state.resume_parser_mode) if st.session_state.resume_parser_mode in ["auto","openai","heuristic"] else 0,
        help="auto = OpenAI if key exists, otherwise heuristic. openai = require key. heuristic = offline rules.",
        key="resume_mode_select",
    )

    uploaded = st.file_uploader(
        "Upload resume file (.pdf, .docx, .txt)",
        type=["pdf", "docx", "txt"],
        help="We extract text locally, then send it to the backend for parsing.",
        key="resume_upload",
    )

    st.session_state.resume_paste = st.text_area(
        "Or paste resume/CV text",
        height=150,
        key="resume_paste_area",
        placeholder="Paste your resume or CV text here...",
    )

    b1, b2 = st.columns([1, 1])

    with b1:
        if st.button("Parse resume → fill profile", key="parse_resume_btn"):
            try:
                resume_text = ""
                if uploaded is not None:
                    resume_text = extract_text_from_upload(uploaded)
                elif (st.session_state.resume_paste or "").strip():
                    resume_text = (st.session_state.resume_paste or "").strip()

                if not resume_text.strip():
                    st.error("Please upload a file or paste resume text first.")
                else:
                    parsed = api_post(
                        "/consumer/profile/parse-resume",
                        {"resume_text": resume_text, "mode": st.session_state.resume_parser_mode},
                        st.session_state.token,
                    )

                    if not isinstance(parsed, dict) or not parsed.get("ok"):
                        st.error((parsed or {}).get("message", "Parse failed."))
                    else:
                        patch = {
                            "name": parsed.get("name"),
                            "location": parsed.get("location"),
                            "skills": parsed.get("skills", ""),
                            "interests": parsed.get("interests", ""),
                            "experience": parsed.get("experience", ""),
                            "education": parsed.get("education", ""),
                            "resume_text": resume_text,
                        }

                        saved = api_post("/profile", patch, st.session_state.token)
                        st.session_state.profile = unwrap_profile_payload(saved)

                        st.success(f"Profile updated from resume (parser: {parsed.get('parser','unknown')}).")
                        st.rerun()
            except Exception as e:
                st.error(str(e))

    with b2:
        if st.button("Clear resume inputs", key="clear_resume_btn"):
            st.session_state.resume_paste = ""
            # file_uploader can’t be programmatically cleared reliably; user can re-upload.
            st.rerun()

    st.divider()

    # Manual editor remains available
    if st.button("Edit Profile"):
        with st.form("profile_form"):
            name = st.text_input("Name", p.get("name",""))
            location = st.text_input("Location", p.get("location",""))
            salary_min = st.number_input("Minimum salary", value=float(p.get("salary_min") or 0))
            skills = st.text_area("Skills", p.get("skills",""), height=100)
            interests = st.text_area("Interests", p.get("interests",""), height=80)
            experience = st.text_area("Experience", p.get("experience",""), height=120)
            education = st.text_area("Education", p.get("education",""), height=80)

            st.caption("You can also paste resume text here manually (saved into your profile).")
            resume_text = st.text_area("Paste resume (optional)", p.get("resume_text",""), height=180)

            if st.form_submit_button("Save profile"):
                try:
                    out = api_post(
                        "/profile",
                        {
                            "name": name,
                            "location": location,
                            "salary_min": salary_min or None,
                            "skills": skills,
                            "interests": interests,
                            "experience": experience,
                            "education": education,
                            "resume_text": resume_text,
                        },
                        st.session_state.token,
                    )
                    st.session_state.profile = unwrap_profile_payload(out)
                    st.success("Profile updated")
                    st.rerun()
                except Exception as e:
                    st.error(str(e))

# =========================================================
# Consumer Mode
# =========================================================
if st.session_state.mode == "Consumer":
    with right:
        st.markdown("## Consumer")

        tab_match, tab_analyze, tab_live = st.tabs(["Match & Explore", "JD Pulse", "Live Hunt"])

        with tab_match:
            st.markdown("### Match & Explore")
            p = st.session_state.profile or {}
            k = st.slider("Number of matches", 5, 25, 10)

            if st.button("Find matches"):
                try:
                    out = api_post(
                        "/consumer/search",
                        {
                            "skills": p.get("skills",""),
                            "interests": p.get("interests",""),
                            "experience": p.get("experience",""),
                            "education": p.get("education",""),
                            "location": p.get("location",""),
                            "salary_min": p.get("salary_min"),
                            "k": k,
                        },
                    )
                    st.session_state.saved_matches = out.get("results", [])
                except Exception as e:
                    st.error(str(e))

            for r in st.session_state.saved_matches:
                st.markdown(
                    f"""
                    <div class="card small">
                        <b>{r.get("title","")}</b><br/>
                        {r.get("company","")} — {r.get("location","")}<br/>
                        Match score: {r.get("_semantic_score") or r.get("_keyword_score") or r.get("_score") or "—"}
                    </div>
                    """,
                    unsafe_allow_html=True,
                )

        with tab_analyze:
            st.markdown("### JD Pulse")
            jd_text = st.text_area("Paste job description", height=240)
            if st.button("Analyze JD"):
                try:
                    out = api_post("/consumer/evaluate-jd", {"jd_text": jd_text})
                    st.json(out)
                except Exception as e:
                    st.error(str(e))

        with tab_live:
            st.markdown("### Live Hunt")
            query = st.text_input("Role / keywords")
            if st.button("Find live jobs"):
                try:
                    p = st.session_state.profile or {}
                    out = api_post(
                        "/consumer/live-jobs",
                        {
                            "query": query,
                            "location": p.get("location",""),
                            "salary_min": p.get("salary_min"),
                            "limit": 20,
                        },
                    )
                    for j in out.get("results", []):
                        st.markdown(
                            f"""
                            <div class="card small">
                                <b>{j.get("title")}</b><br/>
                                {j.get("company","")} — {j.get("location","")}<br/>
                                <a href="{j.get("url")}" target="_blank">View job</a>
                            </div>
                            """,
                            unsafe_allow_html=True,
                        )
                except Exception as e:
                    st.error(str(e))

# =========================================================
# Enterprise Mode
# =========================================================
else:
    with right:
        st.markdown("## Enterprise")

        tab_audit, tab_rewrite, tab_generate = st.tabs(["JD Inspector", "Rewrite Studio", "Comp Builder"])

        with tab_audit:
            jd = st.text_area("Paste JD to audit", height=260)
            if st.button("Audit JD"):
                try:
                    out = api_post("/corporate/analyze-jd", {"jd_text": jd})
                    st.json(out)
                except Exception as e:
                    st.error(str(e))

        with tab_rewrite:
            jd = st.text_area("Existing JD", height=200)
            if st.button("Rewrite JD"):
                try:
                    out = api_post(
                        "/enterprise/rewrite-jd",
                        {"existing_jd": jd, "requirements": {}, "use_openai": True},
                    )
                    st.json(out)
                except Exception as e:
                    st.error(str(e))

        with tab_generate:
            title = st.text_input("Target title")
            budget = st.number_input("Employer budget", value=0)
            if st.button("Generate JD"):
                try:
                    out = api_post(
                        "/enterprise/generate-jd",
                        {
                            "existing_jd": "",
                            "requirements": {"target_title": title, "employer_budget": budget},
                            "use_openai": True,
                        },
                    )
                    st.json(out)
                except Exception as e:
                    st.error(str(e))
